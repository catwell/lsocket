<html>
<head>
<title>lsocket: README</title>
<link rel="stylesheet" href="/res/style.css" />
</head>
<body>

<h1>README</h1>

<h2>lsocket</h2>

<p>A library that provides network programming support for Lua.</p>

<p>Author: Gunnar Z&ouml;tl <gz@tset.de>, 2013-2014.<br />
Released under MIT/X11 license. See file LICENSE for details.</p>

<h2>Introduction</h2>

<p>lsocket provides not complete, but good enough support for socket
programming. It supports IPv4, IPv6 and unix domain sockets, and selects
automatically which one to use based on the address you bind or connect
to. Also, it is almost-nonblocking: except for lsocket.select() and
nameserver lookups, nothing ever blocks (<a href="#fn1" name="r_fn1">*</a>).
And you can also make lsocket.select() nonblocking by passing 0 as a
timeout value. lsocket has been tested with lua 5.1.5, 5.2.3 and luajit
2.0.1 on Linux and Mac OS X.</p>

<h2>Installing</h2>

<p>This uses only stuff that comes with your system. Normally, calling</p>

<code>sudo luarocks install lsocket</code>

<p>or when you have an unpacked source folder,</p>

<code>sudo luarocks make</code>

<p>should do the right thing.</p>

<p>There is also a Makefile in the distribution directory, which has been
created for and on Linux and Mac OS X. This does not cater for
installation, so the luarocks method is preferrable where possible.</p>

<h2>Using</h2>

<code>lsocket = require "lsocket"</code>

<h3>Constructors</h3>

<dl>
	<dt><code>socket = lsocket.bind( [type], [address], [port], [backlog] )</code></dt>
	<dd>
		<p>creates a new socket and binds it locally.</p>
		
		<h4>Arguments</h4>
		
		<dl>
			<dt>type</dt>
			<dd>(optional) type of socket to create, may be "udp", "tcp",
				or "mcast", defaults to "tcp". If the type is mcast, the
				socket will be a udp socket that is additionally set up for
				use as a ipv4 broadcast or ipv6 multicast client socket.
				mcast is not available for unix domain sockets.</dd>
			<dt>address</dt>
			<dd>(optional) ip address or hostname to bind to, defaults to
				lsocket.INADDR_ANY ('0.0.0.0'). If this is an IPv4
                address, the socket will be an IP socket, if it is an
                IPv6 address, the socket will be an IPv6 socket, and if
                it contains a slash (/) character, it will be a unix
                domain socket with the address as the path on the file
                system. On linux, if the first char is '@', then it will
                be a unix domain socket with an abstract socket name,
                i.e. one that does not exist in the file system.</dd>
			<dt>port</dt>
			<dd>port number to bind to, meaningless with unix domain
				sockets.</dd>
			<dt>backlog</dt>
			<dd>(optional) length of connection backlog on this socket,
				defaults to 5. This is only useful for tcp sockets.</dd>
		</dl>
		
		<h4>Returns</h4>
		
		<p>the bound socket, or nil+error message on error.</p>
	</dd>

	<dt><code>socket = lsocket.connect( [type], address, port, [ttl] )</code></dt>
	<dd>
		<p>connects to a remote socket.</p>
		
		<h4>Arguments</h4>
		
		<dl>
			<dt>type</dt>
			<dd>(optional) type of socket to create, may be "udp", "tcp",
				or "mcast", defaults to "tcp". If the type is mcast, the
				socket will be a udp socket that is additionally set up for
				use as a ipv4 broadcast or ipv6 multicast server socket.
				mcast is not available for unix domain sockets.</dd>
			<dt>address</dt>
			<dd>ip address or hostname to connect to. See the address
				parameter to bind() above for a more detailed
				explanation.</dd>
			<dt>port</dt>
			<dd>port number to connect to, meaningless with unix domain
				sockets.</dd>
			<dt>ttl</dt>
			<dd>(optional) ttl for multicast packets, defaults to 1. Only
				useful if type is "mcast".</dd>
		</dl>
		
		<h4>Returns</h4>
		
		<p>the socket in connecting state, or nil+error message on error. Note
			that you need to select() the socket for writing to wait for the
			connect to finish. Of course you can also select the socket for
			reading, but if you select for writing, select() will return as
			soon as the socket is connected, whereas if you select for reading,
			select() will return when the socket is connected and the server
			has sent data. In any case select() will return if the connection
			fails. You should call status() on a socket that was created by
			connect() after it is first returned from select() in order to
			see whether the connection was successful.</p>
	</dd>
</dl>

<h3>Socket Methods</h3>

<dl>
	<dt><code>tbl = socket:info( [what] )</code></dt>
	<dd>
		<p>returns a table with information about the socket.</p>
		
		<h4>Arguments</h4>
		<dl>
			<dt>what</dt>
			<dd>(optional) specify what info you are interested in. The result
				is returned in a table. </dd>
		</dl>

		<h4>Returns</h4>
		
		<p>a table with the requested information:</p>
		
		<ul>
			<li>If what is omitted or nil, return a standard set of socket infos.<br/>
				These fields are in the table:
				<dl>
					<dt>fd</dt><dd>socket file descriptor</dd>
					<dt>family</dt><dd>ip protocol family, "inet" or "inet6"</dd>
					<dt>type</dt><dd>"udp" or "tcp"</dd>
					<dt>listening</dt>
					<dd>true if the socket is listening (created by
						lsocket.bind), false otherwise</dd>
					<dt>multicast</dt>
					<dd>true if the socket is a multicast socket, false
						otherwise. </dd>
				</dl>
			</li>
			<li>If what is "peer", return information about the socket peer.<br/>
				These fields are in the table:
				<dl>
					<dt>family</dt><dd>ip protocol family, "inet" or "inet6"</dd>
					<dt>addr</dt><dd>ip address</dd>
					<dt>port</dt><dd>port number</dd>
				</dl>
				If called on unix domain sockets, this will only return
				useful information for sockets created with lsocket.bind().
			</li>
			<li>If what is "socket", return information about the local
				socket. Fields as for "peer". If called on unix domain
				sockets, this will only return useful information for
				sockets created with lsocket.connect().</li>
		</ul>
		<br/>
	</dd>

	<dt><code>ok, err = socket:status()</code></dt>
	<dd>
		<p>check a sockets error status.</p>
		
		<h4>Returns</h4>
		
		<p>true if the socket has no errors, nil + error message otherwise.</p>
	</dd>

	<dt><code>fd = socket:getfd()</code></dt>
	<dd>
		<p>returns a socket file descriptor. You probably don't need this,
		it is only for interaction with other packages.</p>
		
		<h4>Returns</h4>
		
		<p>the sockets file descriptor.</p>
	</dd>
	
	<dt><code>ok, err = socket.setfd(newfd)</code></dt>
	<dd>
		<p>sets a sockets file descriptor. Only -1 (incalid descriptor)
        is allowed as argument. You probably don't need this, it is
        only for interaction with other packages.</p>
        
        <h4>Returns</h4>
        
        <p>true if the descriptor was -1 and the sockets descriptor has
        been set to -1, nil + error message otherwise.</p>
	</dd>

	<dt><code>sock, addr, port = socket:accept()</code></dt>
	<dd>
		<p>accept a new connection on a socket</p>

		<h4>Returns</h4>
		
		<p>a new socket with the accepted connection and ip address and
		port of the remote end on success, false if no connection is available
		to accept, or nil+error message on error. If called with a unix
		domain socket, addr and port will be nil on success.</p>
	
		<p>This only works on tcp type sockets.</p>
	</dd>

	<dt><code>string = socket:recv( [size] )</code></dt>
	<dd>
		<p>reads data from a socket</p>

		<h4>Arguments</h4>
	
		<dl>
			<dt>size</dt>
			<dd>(optional) the length of the buffer to use for reading,
				defaults to some internal value</dd>
		</dl>

		<h4>Returns</h4>
		
		<p>a string containing the data read, false if no data was
		available to read, nil if the remote end closed the connection (tcp
		connections only), or nil+error message on error.</p>
		
		<p>This should only be used for tcp type sockets, or for udp type sockets
		that have been created by lsocket.connect(). For udp type sockets,
		that have been created with lsocket.bind(), see socket:recvfrom()</p>
	</dd>

	<dt><code>string, address, port = socket:recvfrom( [size] )</code></dt>
	<dd>
		<p>reads data from a socket</p>

		<h4>Arguments</h4>
		<dl>
			<dt>size</dt>
			<dd>(optional) the length of the buffer to use for reading,
				defaults to 4096</dd>
		</dl>
		
		<h4>Returns</h4>
		
		<p>a string containing the data read, and the ip address and
		port number of the remote end of the connection, false if no data was
		available to read, or nil+error message on error.</p>
		
		<p>This should only be used for udp type sockets. For tcp type sockets,
		see socket:recv()</p>
	</dd>

	<dt><code>nbytes = socket:send(string)</code></dt>
	<dd>
		<p>writes data to a socket</p>
		
		<h4>Arguments</h4>
		<dl>
			<dt>string</dt><dd>data to write to the socket</dd>
		</dl>
		
		<h4>Returns</h4>
		
		<p>the number of bytes written, or false if the socket was not
		ready to accept data, or nil+error message on error.</p>

		<p>This should only be used for tcp type sockets, or for udp type sockets
		that have been created by lsocket.connect(). For udp type sockets,
		that have been created with lsocket.bind(), see socket:sendto()</p>
	</dd>

	<dt><code>nbytes = socket:sendto(string, address, port)</code></dt>
	<dd>
		<p>writes data to a socket</p>
		
		<h4>Arguments</h4>
		
		<dl>
			<dt>string</dt><dd>data to write to the socket</dd>
			<dt>address</dt><dd>ip address of remote end of socket to send data to</dd>
			<dt>port</dt><dd>port number of remote end of socket to send data to</dd>
		</dl>
		
		<h4>Returns</h4>
		
		<p>the number of bytes written, or false if the socket was not
		ready to accept data, or nil+error message on error.</p>

		<p>This should only be used for udp type sockets. For tcp type sockets,
		see socket:send()</p>
	</dd>

	<dt><code>ok = socket:close()</code></dt>
	<dd>
		<p>closes a socket</p>

		<h4>Returns</h4>
		
		<p>true if closing the socket went ok, or nil+error message on
		error.</p>
	</dd>
</dl>

<h3>Functions</h3>

<dl>
	<dt><code>[read [, write]] = lsocket.select([read [, write]] , [timeout] )</code></dt>
	<dd>
		<p>calls select() on up to 2 tables of sockets, has timeout</p>
		
		<h4>Arguments</h4>
		
		<dl>
			<dt>read</dt>
			<dd>(opt) table of sockets to wait on for reading</dd>
			<dt>write</dt>
			<dd>(opt) table of sockets to wait on for writing</dd>
			<dt>timeout</dt>
			<dd>(opt) timeout in seconds (millisecond resolution), defaults
				to infinite.</dd>
		</dl>

		<p>Either only the read socket table or values for both socket tables
		must be given. That means, if you want to wait on sockets for writing,
		you will also have to pass a table or nil for reading. The timeout
		value can be specified without passing any tables before it, so
		that lsocket.select(timeout) can be used as a millisecond precision
		sleep function. Closed sockets are ignored by lsocket.select(),
		and it is an error to call lsocket.select() without any open sockets
		and timeout.</p>

		<h4>Returns</h4>
		
		<p>either as many tables as were passed as arguments, each one
		filled with the sockets that became ready from the select, false if
		a timeout occurred before any socket became ready, or nil+error
		message on error.</p>
		
		<p>Note: if you pass nil for the read sockets and some table for the
		write sockets, when a socket you wait on becomes ready, an empty
		table is returned as first return value.</p>
	</dd>

	<dt><code>tbl = lsocket.resolve(name)</code></dt>
	<dd>
		<p>attempts a name resolution of its argument.</p>
		
		<h4>Arguments</h4>
		
		<dl>
			<dt>name</dt><dd>hostname to find ip address(es) for</dd>
		</dl>
		
		<h4>Returns</h4>
		
		<p>a table of ip addresses that the hostname resolves to. For
		each address, a record (subtable) is found in the result table
		with the fields</p>
		
		<dl>
			<dt>family</dt><dd>IP protocol family, "inet" or "inet6"</dd>
			<dt>addr</dt><dd>the ip address</dd>
		</dl>
		
		<p>On error, returns nil + error message.</p>
	</dd>

	<dt><code>tbl = lsocket.getinterfaces()</code></dt>
	<dd>
		<p>enumerate interfaces and their addresses</p>

		<h4>Returns</h4>
		
		<p>a list containing information about all available interfaces.
		For each interface, one or more records (subtables) are found in
		the result table with the fields</p>
		
		<dl>
			<dt>name</dt><dd>interface name</dd>
			<dt>family</dt><dd>IP protocol family, "inet" or "inet6"</dd>
			<dt>addr</dt><dd>the ip address</dd>
			<dt>mask</dt><dd>the netmask</dd>
		</dl>

		<p>On error, returns nil + error message.</p>
	</dd>
</dl>

<h3>Constants</h3>

<dl>
	<dt><code>lsocket.INADDR_ANY</code></dt>
	<dd>IPv4 "any" address, i.e. what you bind to if you intend to
		accept connections on all addresses your computer has.</dd>

	<dt><code>lsocket.IN6ADDR_ANY</code></dt>
	<dd>IPv6 "any" address, see lsocket.INADDR_ANY.</dd>
	
	<dt><code>lsocket._VERSION</code></dt>
	<dd>Version number of the lsocket module.</dd>
</dl>

<h2>Examples</h2>

<p>There are a few examples in the samples folder, including a server and
client for tcp, udp and multicast. For all of those examples, if you
start them without command line arguments, they work with IPv4, if start
them with the argument 6, they work with IPv6.</p>

<h2>Footnotes</h2>

<p><a name="fn1" href="#r_fn1">(*)</a> The functions connect, bind, resolve
and the method sendto transparently use name service resolution, which may
block, if a name server is not available or slow to respond. However, name
service resolution is not used if you pass an IP address (IPv4 or IPv6) or
a path (unix domain) as address argument to those functions.</p>
